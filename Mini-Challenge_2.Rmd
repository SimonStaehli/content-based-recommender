```{r}

INSTALL_LIBS = FALSE

if (INSTALL_LIBS){
  source("install_packages.R")
}

#install packages
library("reshape2")
library("recommenderlab")
library("dplyr")
library("tidyr")
library("ggplot2")
library("vegan")
library("coop")
library("bench")
library("gridExtra")
library("renv")
library("testthat")
library("devtools")
library("fmsb")

#renv::snapshot()
#renv::restore()
```
copy in separate chunk to install if not yet installed




# Content-based Movie Recommender

## Erzeugung von Film- & Nutzerprofilen


1.MovieLense Daten einlesen
```{r}
data("MovieLense")
MovieLense
```

2.Binäre User-Liked-Items Matrix für alle Nutzer erzeugen.
```{r}
########### Param ##########
MINIMUM_RATING = 1
##############################

MovieLense_binary <- recommenderlab::binarize(x = MovieLense, minRating = MINIMUM_RATING)

# Test
check_binary_matrix <- test_that(
  "Check binary matrix", {
    expect_equal(class(as(MovieLense_binary, "matrix")[1]), "logical")
  }
)
```

3.Dimension der User-Liked-Items Matrix prüfen und ausgeben.
```{r}
dim(MovieLense_binary)
```


4.Movie-Genre Matrix für alle Filme erzeugen.
```{r}
movie_genre <- MovieLenseMeta %>%
  dplyr::select(-c(url, year))
```



5.Dimension der Movie-Genre Matrix prüfen und ausgeben.
```{r}
dim(movie_genre)
```


6.Anzahl unterschiedlicher Filmprofile bestimmen und visualisieren.

```{r}
tmp <- movie_genre %>%
  dplyr::select(-title) %>%
  rowSums()

hist(tmp, xlim=c(0,10), 
     col="lightblue", xlab="Number of Genres", 
     ylab="Count", main="Distribution of Ratings per Movie" )
```

**Beschreibung:**

Anhand dieses Plots kann man sehen, dass die Vielzahl der Filme grundsätzlich ein Genre haben. Es gibt jedoch zahlreiche Filme, die mit mehr als einem Genre beschrieben sind. 


```{r}
tmp <- tidyr::pivot_longer(data = movie_genre, cols = 2:dim(movie_genre)[[2]], names_to = "genre")
 
tmp <- tmp[tmp$value > 0, c("title", "genre")] %>%
   group_by(title) %>%
   mutate(combinations = paste0(genre, collapse="-")) %>%
   distinct(title, .keep_all = TRUE) %>%
   select(-genre)
 
combinations <- tmp %>%
 dplyr::group_by(combinations) %>%
 dplyr::count() %>%
 dplyr::arrange(n)



turn_into_wide <- function(df){
#' turn_into_wide
#' Turns a long dataframe into wide dataframe
#'
#' @param df 
#'
#' @return df in wide format
#' @export
#'
#' @examples turn_into_wide(long_dataframe)
 df$value <- 1  
 df <- tidyr::pivot_wider(data = df, names_from = "combinations", values_from = "value")
 
 return(df)
}
 
tmp <- turn_into_wide(df = tmp)

total_unique_combinations <- length(unique(combinations$combinations))
combinations$combinations <- factor(combinations$combinations, levels = combinations$combinations)
 
ggplot2::ggplot(tail(combinations, 25), ggplot2::aes(x = n, y = combinations, label = n)) +
  ggplot2::geom_segment(ggplot2::aes(x = 0, y = combinations, xend = n, yend = combinations), color = "grey50") +
  ggplot2::geom_point(size=3, color = "lightblue") +
  ggplot2::geom_text(nudge_x = 25) +
  ggplot2::theme_bw() + 
  ggplot2::xlab("Counts") + 
  ggplot2::ylab("") +
  ggplot2::ggtitle(paste("Distribution of Genre Combinations (Total: ", total_unique_combinations, ")"))
 
 
 # Test
check_dims_genres <- test_that(
  "Check dims of genre matrices fit with new generated wide df", {
    expect_equal(total_unique_combinations, dim(tmp)[2]-1)
     }
)

```
**Beschreibung:**
Der Plot zeigt die Anzahl der Counts pro Genre. Der Plot zeigt, dass das Genre "Drama" und "Comedy" klar die meisten
Filme besitzen. Es hat sehr wenig Filme in den Bereichen "unkown", was gut ist. Gemäss dem vorherigen Plot wird die Grafik auch getrübt, dadurch, dass 
gewisse Filme über mehrere Genres verfügen. Es könnte sein, dass es viele Filme im Datensatz gibt, die nicht primär nur "Drama" Filme sind.



7.User-Genre-Profil Matrix mit Nutzerprofilen im Genre-Vektorraum erzeugen.
```{r}
########## Param ##########
NORMALIZED_BY_VIEWS <- TRUE

###########################
# Convert both into matrices
user_movie_mat <- as(MovieLense_binary, "matrix")


movie_genre_mat <- movie_genre %>%
  dplyr::select(-title) %>%
  as.matrix()

# Create user genre profile
if (NORMALIZED_BY_VIEWS){
  user_genre_mat <- ((user_movie_mat / as.vector(rowSums(user_movie_mat)))  %*% movie_genre_mat)
} else {
  user_genre_mat <- user_movie_mat %*% movie_genre_mat
}


# Test
check_both_matrices <- test_that(
  "Check matrices types", {
    expect_equal(class(user_movie_mat), class(movie_genre_mat))
  }
)

check_mat_dim <- test_that(
  "Check mat dims", {
    expect_equal(dim(user_movie_mat)[2], dim(movie_genre)[1])
  }
)

check_mat_dim_out <- test_that(
  "Check mat dims output", {
    expect_equal(dim(user_genre_mat), c(dim(user_movie_mat)[1], dim(movie_genre_mat)[2]))
  }
)
```
Achtung! Die Werte können grössere Werte als 1 pro User annehmen trotz Normalisierung der Gesamtviews per User, da gewisse Filme über mehrere
Genres verfügen.


8.Dimension der User-Genre-Profil Matrix prüfen und ausgeben.
```{r}
dim(user_genre_mat)
```
Die Matrix zeigt über die Reihen hinweg alle User und über die Spalten hinweg alle erzeugten Scores bezüglich ihrer Relation zu
einem bestimmten Genre.


9.Anzahl unterschiedlicher Nutzerprofile bestimmen, wenn Stärke der GenreKombination (a) vollständig bzw. (b) nur binär berücksichtigt wird.
```{r}
BINARY_THRESHOLD <- 0

# Create Binaray User-Genre Matrix
user_genre_mat_binary <- ifelse(user_genre_mat > BINARY_THRESHOLD, 1, 0)

plot_user_profiles <- function(M, user_idx = NULL, 
                              sample_size = 20, n_cols = 4){
  #' Plots all user profiles
  #'
  #' params:
  #'    user_genre_mat:   Matrix consisting of user genre ratings
  #'    sample_size:      Size of the sample to take
  #'    n_cols:           Ncols to plot.
  #' 
  #' in the Description section
  #'
  #' This part goes in the Details!
  if (user_idx){
    user_selection <- M[user_idx, ]
  } else {
    random_idx <- sample(seq(1, dim(M)[[1]]), 
                        size = sample_size)
    user_selection <- M[random_idx, ]
  }  
  user_selection <- as.data.frame(user_selection)
  user_selection <- rbind(rep(max(user_selection), 
                              nrow(user_selection)), 
                          rep(min(user_selection),
                             nrow(user_selection)), 
                                  user_selection)
  n_rows <- as.integer(sample_size / n_cols)
  par(mar = rep(1, 4))
  par(mfrow = c(n_rows, 4))

  for (i in 3:nrow(user_selection)){
    fmsb::radarchart(
      df  = user_selection[c(1:2, i), ],  
      pcol=rgb(0.2,0.5,0.5,0.9) , pfcol=rgb(0.2,0.5,0.5,0.5),
      plwd = 1, cglcol="grey", cglty=1, axislabcol="grey", caxislabels=seq(0,20,5), cglwd=0.8,
      vlcex=0.8, title = paste("User: ", row.names(user_selection)[i]))
    }
  }

random_idx <- sample(seq(1, dim(user_genre_mat_binary)[[1]]), 
                        size = 8)
plot_user_profiles(user_genre_mat_binary, user_idx = random_idx, 
                    sample_size = 8)
plot_user_profiles(user_genre_mat, user_idx = random_idx, 
                    sample_size = 8)
```
**Beschreibung:**

Die beiden Plots unterscheiden sich stark in ihren Wertebereichen. Der Wertebereich des binärisierten
Plots reicht bei jedem Nutzer von 0 bis nach 1. Die Grafik des binären Plots veränderts sich wenn der BINARY_THRESHOLD
verändert wird. Der Plot mit den normalen Ratings sieht wie erwartet aus. Die Spiderdiagramme zeigen die stärkste Ausprägung
meistens bei dem Genre Drama.


## Ähnlichkeit von Nutzern und Filmen
1.Cosinus-Ähnlichkeit zwischen User-Genre- und Movie-Genre-Matrix berechnen.
2.Dimension der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen prüfen uns ausgeben.
3.5-Zahlen Statistik für Matrix der Cosinus-Ähnlichkeiten prüfen uns ausgeben.
4.Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot visualisieren.
5.Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot für Nutzer “241”, “414”, “477”, “526”, “640” und “710” visualisieren.




## Empfehlbare Filme

1.Bewertete Filme maskieren, d.h. “Negativabzug” der User-Items Matrix erzeugen, um anschliessend Empfehlungen herzuleiten.
2.Zeilensumme des “Negativabzuges” der User-Items Matrix für die User “5”, “25”, “50” und “150” ausgeben.
3.5-Zahlen Statistik der Zeilensumme des “Negativabzuges” der User-Items Matrix bestimmen.




## Top-N Empfehlungen

1.Matrix für Bewertung aller Filme durch element-weise Multiplikation der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen und “Negativabzug” der User-Items Matrix erzeugen.
2.Dimension der Matrix für die Bewertung aller Filme prüfen.
3.Top-20 Listen pro Nutzer extrahieren.
4.Länge der Top-20 Listen pro Nutzer prüfen.
5.Verteilung der minimalen Ähnlichkeit für Top-N Listen für N = 10, 20, 50 und 100 für alle Nutzer visuell vergleichen.
6.Top-20 Empfehlungen für Nutzer “5”, “25”, “50” und “150” visuell evaluieren.
7.Für Nutzer “133” und “555” Profil mit Top-N Empfehlungen für N = 20, 30, 40, 50 analysieren, visualisieren und diskutieren.




