```{r}
INSTALL_LIBS = FALSE

if (INSTALL_LIBS){
  source("install_packages.R")
}

#install packages
library("reshape2")
library("recommenderlab")
library("dplyr")
library("tidyr")
library("ggplot2")
library("vegan")
library("coop")
library("bench")
library("gridExtra")
library("renv")
library("testthat")
library("devtools")
library("fmsb")
library("ggridges")


source("./src/helper.R")

#renv::snapshot()
#renv::restore()
```


# Content-based Movie Recommender

## Erzeugung von Film- & Nutzerprofilen


1.MovieLense Daten einlesen
```{r}
data("MovieLense")
MovieLense
```

2.Binäre User-Liked-Items Matrix für alle Nutzer erzeugen.
```{r}
########### Param ##########
MINIMUM_RATING = 3
##############################

MovieLense_binary <- recommenderlab::binarize(x = MovieLense, minRating = MINIMUM_RATING)

# Test
check_binary_matrix <- test_that(
  "Check binary matrix", {
    expect_equal(class(as(MovieLense_binary, "matrix")[1]), "logical")
  }
)
```

3.Dimension der User-Liked-Items Matrix prüfen und ausgeben.
```{r}
dim(MovieLense_binary)
MovieLense_binary_matrix = as(MovieLense_binary, "matrix")
```


4.Movie-Genre Matrix für alle Filme erzeugen.
```{r}
movie_genre <- MovieLenseMeta %>%
  dplyr::select(-c(url, year))
```



5.Dimension der Movie-Genre Matrix prüfen und ausgeben.
```{r}
dim(movie_genre)
```


6.Anzahl unterschiedlicher Filmprofile bestimmen und visualisieren.

```{r}
number_of_genres <- movie_genre %>%
  dplyr::select(-title) %>%
  rowSums()

ggplot(data.frame(data.frame(number_of_genres)), aes(number_of_genres)) +
  geom_histogram(bins=6) +   
  ggplot2::theme_bw() + 
  ggplot2::xlab("Number of different genres per Movie") + 
  ggplot2::ylab("Count") +
  ggplot2::ggtitle('Count of different Genres per Movie') +
  ggplot2::theme(panel.border = element_blank(),
                 axis.line = element_line(colour = "black"))

```

**Beschreibung:**

Anhand dieses Plots kann man sehen, dass die Vielzahl der Filme grundsätzlich ein Genre haben. Es gibt jedoch zahlreiche Filme, die mit mehr als einem Genre beschrieben sind. Die Anzahl der unterschiedlichen Genres pro Film reicht sogar bis maximal 6 Filme insgesamt.

```{r}
tmp <- tidyr::pivot_longer(data = movie_genre, cols = 2:dim(movie_genre)[[2]], names_to = "genre")
 
tmp <- tmp[tmp$value > 0, c("title", "genre")] %>%
   group_by(title) %>%
   mutate(combinations = paste0(genre, collapse="-")) %>%
   distinct(title, .keep_all = TRUE) %>%
   select(-genre)
 
combinations <- tmp %>%
 dplyr::group_by(combinations) %>%
 dplyr::count() %>%
 dplyr::arrange(n)

# use helper file to transform
tmp <- turn_into_wide(df = tmp)

total_unique_combinations <- length(unique(combinations$combinations))
combinations$combinations <- factor(combinations$combinations, levels = combinations$combinations)
 
ggplot2::ggplot(tail(combinations, 25), ggplot2::aes(x = n, y = combinations, label = n)) +
  ggplot2::geom_segment(ggplot2::aes(x = 0, y = combinations, xend = n, yend = combinations), color = "grey50") +
  ggplot2::geom_point(size=3, color = "lightblue") +
  ggplot2::geom_text(nudge_x = 25, size = 3) +
  ggplot2::theme_bw() + 
  ggplot2::xlab("Counts") + 
  ggplot2::ylab("") +
  ggplot2::ggtitle(paste("Distribution of Genre Combinations (Total: ", total_unique_combinations, ")")) +
  ggplot2::theme(panel.border = element_blank(),
                 axis.line = element_line(colour = "black"))

 
 
 # Test
check_dims_genres <- test_that(
  "Check dims of genre matrices fit with new generated wide df", {
    expect_equal(total_unique_combinations, dim(tmp)[2]-1)
     }
)

```
**Beschreibung:**
Der Plot zeigt die Anzahl der Counts pro Genre. Der Plot zeigt, dass das Genre "Drama" und "Comedy" klar die meisten
Filme besitzen. Es hat sehr wenig Filme in den Bereichen "unkown", was gut ist. Gemäss dem vorherigen Plot wird die Grafik auch getrübt, dadurch, dass 
gewisse Filme über mehrere Genres verfügen. Es könnte sein, dass es viele Filme im Datensatz gibt, die nicht primär nur "Drama" Filme sind.



7.User-Genre-Profil Matrix mit Nutzerprofilen im Genre-Vektorraum erzeugen.
```{r}
########## Param ##########
NORMALIZED_BY_VIEWS <- TRUE

###########################
# Convert both into matrices
user_movie_mat <- as(MovieLense_binary, "matrix")


movie_genre_mat <- movie_genre %>%
  dplyr::select(-title) %>%
  as.matrix()

# Create user genre profile
if (NORMALIZED_BY_VIEWS){
  user_genre_mat <- ((user_movie_mat / as.vector(rowSums(user_movie_mat))) %*% movie_genre_mat)
} else {
  user_genre_mat <- user_movie_mat %*% movie_genre_mat
}


# Test
check_both_matrices <- test_that(
  "Check matrices types", {
    expect_equal(class(user_movie_mat), class(movie_genre_mat))
  }
)

check_mat_dim <- test_that(
  "Check mat dims", {
    expect_equal(dim(user_movie_mat)[2], dim(movie_genre)[1])
  }
)

check_mat_dim_out <- test_that(
  "Check mat dims output", {
    expect_equal(dim(user_genre_mat), c(dim(user_movie_mat)[1], dim(movie_genre_mat)[2]))
  }
)
```
Achtung! Die Werte können grössere Werte als 1 pro User annehmen trotz Normalisierung der Gesamtviews per User, da gewisse Filme über mehrere
Genres verfügen.


8.Dimension der User-Genre-Profil Matrix prüfen und ausgeben.
```{r}
dim(user_genre_mat)
```
Die Matrix zeigt über die Reihen hinweg alle User und über die Spalten hinweg alle erzeugten Scores bezüglich ihrer Relation zu
einem bestimmten Genre.


9.Anzahl unterschiedlicher Nutzerprofile bestimmen, wenn Stärke der GenreKombination (a) vollständig bzw. (b) nur binär berücksichtigt wird.
```{r}
BINARY_THRESHOLD <- 0

# Create Binaray User-Genre Matrix
user_genre_mat_binary <- ifelse(user_genre_mat > BINARY_THRESHOLD, 1, 0)
random_idx <- sample(seq(1, dim(user_genre_mat_binary)[[1]]), 
                        size = 8)

plot_user_profiles(user_genre_mat_binary, user_idx = random_idx, 
                    sample_size = 8)
plot_user_profiles(user_genre_mat, user_idx = random_idx, 
                    sample_size = 8)
```
**Beschreibung:**

Die beiden Plots unterscheiden sich stark in ihren Wertebereichen. Der Wertebereich des binärisierten
Plots reicht bei jedem Nutzer von 0 bis nach 1. Die Grafik des binären Plots veränderts sich wenn der BINARY_THRESHOLD
verändert wird. Der Plot mit den normalen Ratings sieht wie erwartet aus. Die Spiderdiagramme zeigen die stärkste Ausprägung
meistens bei dem Genre Drama, was durchaus sinn macht, da es das meistgesehene Genre im Datensatz ist und auch am meisten Filme unter diesem 
Genre zu finden sind.


## Ähnlichkeit von Nutzern und Filmen
1.Cosinus-Ähnlichkeit zwischen User-Genre- und Movie-Genre-Matrix berechnen.

```{r}
similarity_matrix <- calc_cosine_similarity(user_genre_mat, movie_genre_mat)

# Check similarity results with package coop
check_similarity_results <- test_that(
  "Check mat dims with users", {
    expect_equal(similarity_matrix[1,1]  ,coop::cosine(user_genre_mat[1, ] ,movie_genre_mat[1, ]) )
  }
)
```
`user_gerne_mat` beinhaltet, welche genre ein user gern hat und `movie_gerne_mat`, welche genre ein Film hat.

2.Dimension der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen prüfen uns ausgeben.
```{r}
dim(similarity_matrix)

# Run Tests on Dimensionality fo Similarity Matrix
check_mat_dim <- test_that(
  "Check mat dims with users", {
    expect_equal(dim(similarity_matrix)[1], dim(user_genre_mat)[1])
    expect_equal(dim(similarity_matrix)[2], dim(movie_genre_mat)[1])
  }
)
```
3.5-Zahlen Statistik für Matrix der Cosinus-Ähnlichkeiten prüfen uns ausgeben.
```{r}
fivenum(similarity_matrix)
```
4.Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot visualisieren.
```{r}
tmp <- as.vector(similarity_matrix)
tmp <- as.data.frame(tmp)

ggplot2::ggplot(data = tmp, aes(x = tmp)) +
  ggplot2::geom_histogram(fill = "grey", color = "black", 
                        adjust = 1.5, alpha = .9) +
  ggplot2::geom_density(color="black") +
  ggplot2::labs(title = "Distribution of Similarity Matrix") +
  ggplot2::xlab("Cosine Similarities") +
  theme_classic()
```
**Beschreibung:**
Der Plot zeigt die Verteilung der berechneten Ähnlichkeitsmasse pro User und Film innerhalb des Datensatzes.
Man erkennt eine starke Ausprägung der Nullwerte, respektive gar keine Similarity zwischen Nutzer und Filmen. Dies 
lässt sich mit der These vereinbaren, dass es Nutzer gibt, die fast keine Filme geschaut und vice-versa Filme, die fast nie geschaut
wurden. Ohne die starke Ausprägung wäre das Histogram praktisch normalverteilt.



5.Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot für Nutzer “241”, “414”, “477”, “526”, “640” und “710” visualisieren.
```{r}
user_selection <- similarity_matrix[c(241, 414, 477, 526, 640, 710), ]
row.names(user_selection)

user_selection <- as.data.frame(t(user_selection)) %>%
  reshape2::melt(value.name = "similarity")

colnames(user_selection) <- c("user", "similarity")

ggplot2::ggplot(data = user_selection, ggplot2::aes(x = similarity)) + 
  ggplot2::geom_boxplot(fill="grey", color = "black", notch = TRUE) + 
  facet_grid(rows = vars(user)) + 
  xlim(0, 1) + 
  labs(title = "Distribution of Similarities between User and Movies") + 
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())
```
**Beschreibung:**

Der Plot zeigt die Verteilung der Similarites zwischen einem User und allen Filmen. Auf der rechten Seite ist die jeweilige 
ID des Users verzeichnet. Die Daten wurden anhand eines Boxplots visualisiert, um Unterschiede zwischen den Usern besser zu erkennen.
Man kann auf den ersten Blick anhand des Notches (95% Konfidenzintervall vom Mittelwert), dass sich die Nutzer statistisch signifikant voneinander
unterscheiden hinsichtlich ihrer Ähnlichkeit zwischen den Filmen. Eine weitere Auffälligkeit sind die einzelnen Ausreisser der Ähnlickeitsmasse von Nutzer 640, die aber auch auf die kleine Streuung der Similarities für diesen Nutzer zurückzuführen sind.


## Empfehlbare Filme

1.Bewertete Filme maskieren, d.h. “Negativabzug” der User-Items Matrix erzeugen, um anschliessend Empfehlungen herzuleiten.
```{r}
MovieLenseMat = as(MovieLense, "matrix")
MovieLenseMat_mask = ifelse(is.na(MovieLenseMat), 1, 0)

#(MovieLenseMat)
#image(MovieLenseMat_mask)
```
**Beschreibung:**

Oben können wir die beiden Matrizen als Bild betrachten: Das Erste ist der normale Movielense-Datensatz und das Zweite ist der "Negativabzug". Im "Negativabzug" sind alle NA-Werte eine 1 und alle anderen eine 0. Da der durchschnittliche Nutzer nur wenige Filme bewertet, hat das erste Bild nur wenige Datenpunkte. Das Zweite ist genau das Gegenteil davon.



2.Zeilensumme des “Negativabzuges” der User-Items Matrix für die User “5”, “25”, “50” und “150” ausgeben.
```{r}
SELECTED_USERS = c(5, 25, 50, 150)
###
Mask_sum = MovieLenseMat_mask
Mask_sum = data.frame(Sum = rowSums(Mask_sum))
Mask_sum$User <- factor(row.names(Mask_sum))

### Select users
sum_mask_users = Mask_sum[Mask_sum$User %in% SELECTED_USERS,]
sum_mask_users$User <- factor(sum_mask_users$User, levels = SELECTED_USERS)

#orginal-dimension of the matrix
dim(MovieLense)

ggplot(data=sum_mask_users, aes(x=User, y=Sum)) +
  ggplot2::geom_bar(stat="identity", alpha = .7) +   
  ggplot2::geom_text(aes(label=Sum), vjust=1.6, color="white", size=3.5) +
  ggplot2::ggtitle('Sum of unrated Movies of selected Users') +
  ggplot2::theme_bw() +
  ggplot2::theme(panel.border = element_blank(),
                 panel.grid.major = element_blank(),
                 axis.line = element_line(colour = "black")) +
  ggplot2::ylim(0, max(sum_mask_users$Sum)) +
  ggplot2::theme_classic()

```
**Beschreibung:**

Es scheint so, als gäbe es keine großen Unterschiede zwischen den Nutzern. Das liegt daran, dass wir uns die Filme ansehen, die von den Nutzern nicht bewertet wurden. Da es so viele verschiedene Filme gibt (1664), ist es normal, dass jeder eine so hohe Anzahl an nicht bewerteten Filmen hat. Zum Beispiel können wir sagen, dass der Nutzer 5 die meisten Filme bewertet hat und deshalb die niedrigste Anzahl an nicht bewerteten Filmen aufweist.


3.5-Zahlen Statistik der Zeilensumme des “Negativabzuges” der User-Items Matrix bestimmen.
```{r}
fivenum(Mask_sum$Sum)

```
Die Statistik zeigt die wichtigsten Komponenten der Daten Minimum, Q1, Median, Q3 und Maximum der Daten.
Ausserdem sieht man hier auch, dass die  Verteilung eher linksschief sein muss, weil die 75% aller Datenpunkte grösser ist als Q1.



```{r}
# Horizontal
ggplot(Mask_sum, aes(y=Sum)) + 
  ggplot2::geom_boxplot(fill = "grey", alpha = .5) +
  ggplot2::ggtitle('Boxplot of Sum of unrated Movies per User') + 
  ggplot2::theme_bw() +
  coord_flip() + theme_bw() +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.border = element_blank(), 
        axis.line = element_line())
```
**Beschreibung:**
Der Plot unterstützt die Annahmen anhander Tukey-Fünfnummer Statistik nochmals. Mit Hilfe der Grafik können wir feststellen, 
dass wir die meisten Daten um 1600 haben. wir können auch sagen, dass dies eine Zahl ist, die sehr nahe an der maximalen Anzahl von Filmen (1664) liegt. wir haben viele Ausreißer in den unteren Werten. Der Minimalwert liegt bei 929. 
Es gibt also einen Nutzer, der 929 Filme nicht bewertet hat. Der höchste Wert liegt bei 1645. Das ist sehr verwunderlich, weil wir dachten, dass er bei 1664 liegen würde, weil es immer Leute geben sollte, die nie einen Film bewerten. Aber in diesem Datensatz ist das nicht der Fall.



## Top-N Empfehlungen

1.Matrix für Bewertung aller Filme durch element-weise Multiplikation der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen und “Negativabzug” der User-Items Matrix erzeugen.

```{r}
# Hadamart-Produkt
# BEsser ausschreiben (xy label, was sehe ich?)
# Grafik + Text + Legende sollte die ganze Grafik erklären
similarity_users <- MovieLenseMat_mask * similarity_matrix  

df <- melt(t(similarity_users[1:5,1:5]))

colnames(df) <- c("x", "y", "value")
ggplot(df, aes(x = x, y = y, fill = value)) +
  geom_tile() + 
  theme(axis.title.x=element_blank()
        ) +
  ggplot2::ggtitle('Genre-similarties for unseen movies for 5 selected Movies and Users.') +
  ggplot2::ylab('User ID')

df <- melt(t(similarity_users[1,]))

colnames(df) <- c("x", "y", "value")
ggplot(df, aes(x = y, y = x, fill = value)) +
  geom_tile() + 
  theme(axis.title.y=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.x=element_blank(),
        ) +
  ggplot2::ggtitle('Genre-similarties for unseen movies for a selected user') +
  ggplot2::xlab('Movie ID') 

similarity_users_melted <- melt(t(similarity_users))
users_num = c(1,2,3,4,5,6,7,8,9,10)

df1 <- similarity_users_melted[similarity_users_melted$Var2 == 1,]
df1 <- similarity_users_melted[similarity_users_melted$Var2 %in% users_num, ]

colnames(df1) <- c("x", "y", "value")
ggplot(df1, aes(x = x, y = y, fill = value)) +
  geom_tile() + 
  theme(axis.title.y=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.x=element_blank(),
        ) +
  ggplot2::ggtitle('Genre-similarties for unseen movies for the first 10 users') +
  ggplot2::xlab('Movie ID') +
  facet_grid(rows = df1$y, scales = "free")

```
**Beschreibung:**

Wir betrachten hier oben verschiedene Visualisierungen über die Genre-Ähnlichkeiten für ungesehene Filme für User

In der ersten Grafik sehen wir zunächst 5 Filme und die ersten 5 User. Dort können wir sehen, dass User 1 alle ausgewählten Filme gesehen hat (sortiert nach ID).

Auf der zweiten Grafik sehen wir mehr Informationen über die anderen Filme für Benutzer 1. Es sieht so aus, als ob dieser Benutzer Filme nach Index sortiert ansieht (lol). die anderen Linien, die aus der Ferne wie ein Barcode aussehen, sind Filme mit einer anderen Recommendation für den User 1.

Die letzte Abbildung ist eine Übersicht über die ersten 10 Nutzer und alle Genre-Ähnlichkeiten für die ungesehenen Filme. Man kann hier sehen, dass alle User komplett unterschiedliche Empfehlungen basierend auf dem Genre haben.


2.Dimension der Matrix für die Bewertung aller Filme prüfen.

```{r}
dim(similarity_users)
```
3.Top-20 Listen pro Nutzer extrahieren.
```{r}
top_top20_recos <- get_topn_recos(similarity_users_melted, 20)
top_top20_recos
```

4.Länge der Top-20 Listen pro Nutzer prüfen.

```{r}
#test with a user
top_top20_recos_user_42 <- top_top20_recos[top_top20_recos$Var2 %in% 42, ]

#5-Zahlen Statistik
fivenum(top_top20_recos_user_42$value)

top20_mean_group_size <- top_top20_recos %>%
  group_by(Var2) %>%
  summarise(group_size = n())

expect_equal(all(top20_mean_group_size$group_size == 20), TRUE)
```
Man kann anhand der Kennzahlen sehen, dass die Similarites sehr eng streuen. Die Range der Similarities reicht ist im Wertebereich von 0.68 - 0.77. Es war jedoch auch zu erwarten, dass der Wertebereich der Ähnlichkeiten von den Top-N Empfehlungen hoch ausfällt.

**Beschreibung:**

Wie erwartet, besteht die Top20 Liste für jeden User aus 20 Filmen.


5.Verteilung der minimalen Ähnlichkeit für Top-N Listen für N = 10, 20, 50 und 100 für alle Nutzer visuell vergleichen.
```{r}
top_n_intervall = c(10, 20, 50, 100)
top_n_col_names = c('1. Top 10', '2. Top 20', '3. Top 50', '4. Top 100')
#create data frame with 0 rows and 5 columns
min_similarity_top_n <- data.frame(matrix(ncol = 1, nrow = length(row.names(similarity_users))))
#provide column names
colnames(min_similarity_top_n) <- c('User')
min_similarity_top_n$User <- row.names(similarity_users)

for (i in 1:4) {
  top_n_recos = get_topn_recos(similarity_users_melted, top_n_intervall[i])
  
  min_top_n_recos = top_n_recos %>% 
    select(Var2, value) %>%
    group_by(Var2) %>%  
    mutate(
    MinSimilarity = min(value, na.rm = T),
    User = min(Var2, na.rm = T)
    ) %>% select(User, MinSimilarity) %>%
    distinct(.keep_all = TRUE)

  min_similarity_top_n[,top_n_col_names[i]] <- min_top_n_recos$MinSimilarity
}
min_similarity_top_n_long = pivot_longer(min_similarity_top_n, cols=top_n_col_names, names_to='TopN', values_to='MinSimilarity')
min_similarity_top_n_long
```

```{r}
# Notched boxplot, what is it?
ggplot2::ggplot(min_similarity_top_n_long, ggplot2::aes(x=MinSimilarity)) + 
  ggplot2::geom_histogram(bins=50)+
  ggplot2::labs(title = "Min Similarity Distrubtion per Top N List")+
  ggplot2::facet_grid(TopN ~ .)
```

**Beschreibung:**
Im oberen Plot sehen wir, dass der Modus der Mindest-Similarity abnimmt bei einem grösseren N bei der TopN Liste. Bei der Top100 sehen wir, dass die Mindest-Similarity bis under 0.4 fällt. Das führt also zu wahrscheinlich ungeeigneten Empfehlungen.


6.Top-20 Empfehlungen für Nutzer “5”, “25”, “50” und “150” visuell evaluieren.
```{r}
# Histogram zuerst, nicht multimodal (bei 1x hügel, boxplot gut, sonst eher histogram.)
# Hinweis lesen! Vergleich mit Ground Truth (ist der Recommender gut?)
# Radar plot Topn genres vs ground truth genres.
top_top20_recos_users <- top_top20_recos[top_top20_recos$Var2 %in% c(5, 25, 50, 150), ]
top_top20_recos_users$User = top_top20_recos_users$Var2
top_top20_recos_users$Similarity = top_top20_recos_users$value


ggplot2::ggplot(top_top20_recos_users, ggplot2::aes(x=Similarity)) + 
  ggplot2::geom_histogram(bins=20)+
  ggplot2::labs(title = "Similarity Distrubtion for selected Users") +
  ggplot2::facet_grid(User ~ .) +
  ggplot2::theme_bw()

```
**Beschreibung:**

Es ist interessant zu sehen, wie sehr die Top20-Similarity für verschiedene User variiert. Das zeigt uns, dass unser Recommender für verschiedene User verschiedene Empfehlungen macht. 


7.Für Nutzer “133” und “555” Profil mit Top-N Empfehlungen für N = 20, 30, 40, 50 analysieren, visualisieren und diskutieren.
```{r}
top_n_intervall = c(20, 30, 40, 50)
top_n_col_names = c('Top 20', 'Top 30', 'Top 40', 'Top 50')
users = c(133, 55)
#create data frame with 0 rows and 5 columns
top_n_list_selected_users <- data.frame(matrix(ncol = 3, nrow = 0))

#provide column names
colnames(min_similarity_top_n) <- c('User', 'TopN', 'Similarity')
selected_users = similarity_users_melted[similarity_users_melted$Var2 %in% users,  ]

for (i in 1:4) {
  top_n_recos = get_topn_recos(selected_users, top_n_intervall[i])
  top_n_recos$User = top_n_recos$Var2
  top_n_recos$Similarity = top_n_recos$value
  top_n_recos$TopN = top_n_col_names[i]
  top_n_recos <- top_n_recos %>%
    select(User, TopN, Similarity)
  top_n_list_selected_users <- rbind(top_n_list_selected_users,top_n_recos)
}
top_n_list_selected_users
```

```{r}
# Mehr distukieren und analysieren.
ggplot2::ggplot(data = top_n_list_selected_users, 
                ggplot2::aes(x = factor(User), y = Similarity, , fill=factor(TopN))) + 
  ggplot2::geom_boxplot() +
  ggplot2::scale_fill_brewer(palette = "Blues") + 
  labs(title = "Similarity Distrubtion for selected Users and selected TopN List")
```
**Beschreibung:**

Wir sehen, dass das Minimum der Similarities mit mehr Empfehlungen abnimmt. Dies ergibt auch Sinn, da die TopN-Empfehlungen die Filme empfiehlt, welche die höchste Similarity haben zu Filmen, welche man bewertet hat. Somit werden bei einem höheren N auch Filme empfohlen mit einer niedrigeren Similarity. Hier muss man also anpassen, dass man ein geschicktes N wählt: Ein User soll viele Filme empfohlen bekommen, welche aber auch für den User passen. Falls man also z.B. eine mindest-Similarity für Empfehlungen einbaut, muss man auch eine Mindest-Anzahl an Empfehlungen einbauen. Somit soll jeder User mindestens N Filme empfohlen bekommen, aber danach nur Filme, welche über dieser Mndest-Similarity sind.

Ein anderer Ansatz wäre auch, dass eine zufällige Empfehlung nicht 100% zufällig ist, sondern einfach ein Film, welcher knapp unter dieser Mindest-Similarity liegt.

```{r}
user_profiles <-  analyze_topn_recos(selected_users, 50)
create_cleveland_plot(user_profiles)

```
**Beschreibung:**

Rot sind unsere Recommendations und grün ist die Ground Truth. Wir sehen, dass der User 55 War, Thriller, Sci-Fi, Drama, Adventure und Action gern schaut und diese auch häufiger empfohlen bekommt. Dasselbe sehen wir mit User 133, welcher Drama liebt und dieses auch das häufigste Genre der empfohlenen Filme ist. Unser Recommender empfiehlt also Filme, welche zu den beiden Usern passen! Es ist natürlich nicht perfekt, da es nicht unendlich viele Filme gibt und die User auch keinen Film empfohlen bekommen möchten, welchen sie schon geschaut haben.
