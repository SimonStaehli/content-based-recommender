```{r}

INSTALL_LIBS = FALSE

if (INSTALL_LIBS){
  source("install_packages.R")
}

#install packages
library("reshape2")
library("recommenderlab")
library("dplyr")
library("tidyr")
library("ggplot2")
library("vegan")
library("coop")
library("bench")
library("gridExtra")
library("renv")
library("testthat")
library("devtools")
library("fmsb")

#renv::snapshot()
#renv::restore()
```


# Content-based Movie Recommender

## Erzeugung von Film- & Nutzerprofilen


1.MovieLense Daten einlesen
```{r}
data("MovieLense")
MovieLense
```

2.Binäre User-Liked-Items Matrix für alle Nutzer erzeugen.
```{r}
########### Param ##########
MINIMUM_RATING = 1
##############################

MovieLense_binary <- recommenderlab::binarize(x = MovieLense, minRating = MINIMUM_RATING)

# Test
check_binary_matrix <- test_that(
  "Check binary matrix", {
    expect_equal(class(as(MovieLense_binary, "matrix")[1]), "logical")
  }
)
```

3.Dimension der User-Liked-Items Matrix prüfen und ausgeben.
```{r}
dim(MovieLense_binary)
```


4.Movie-Genre Matrix für alle Filme erzeugen.
```{r}
movie_genre <- MovieLenseMeta %>%
  dplyr::select(-c(url, year))
```



5.Dimension der Movie-Genre Matrix prüfen und ausgeben.
```{r}
dim(movie_genre)
```


6.Anzahl unterschiedlicher Filmprofile bestimmen und visualisieren.


```{r}
Number_of_Genres <- movie_genre %>%
  dplyr::select(-title) %>%
  rowSums()

  
  #ggplot2::hist(tmp, xlim=c(0,6), 
  #   col="lightblue", xlab="Number of Genres", 
   #  ylab="Count", main="Numbers of Genre per Movie" )
```


```{r}
Number_of_Genres <- movie_genre %>%
  dplyr::select(-title) %>%
  rowSums()

ggplot(data.frame(data.frame(Number_of_Genres)), aes(Number_of_Genres)) +
  geom_histogram(bins=6) +   
  ggplot2::theme_bw() + 
  ggplot2::xlab("Number of different genres per Movie") + 
  ggplot2::ylab("Count") +
  ggplot2::ggtitle('Histogram of Numbers of different Genres per Movie')
```

**Beschreibung:**

Anhand dieses Plots kann man sehen, dass die Vielzahl der Filme grundsätzlich ein Genre haben. Es gibt jedoch zahlreiche Filme, die mit mehr als einem Genre beschrieben sind. 
```{r}
tmp <- tidyr::pivot_longer(data = movie_genre, cols = 2:dim(movie_genre)[[2]], names_to = "genre")
 
tmp <- tmp[tmp$value > 0, c("title", "genre")] %>%
   group_by(title) %>%
   mutate(combinations = paste0(genre, collapse="-")) %>%
   distinct(title, .keep_all = TRUE) %>%
   select(-genre)
 
combinations <- tmp %>%
 dplyr::group_by(combinations) %>%
 dplyr::count() %>%
 dplyr::arrange(n)



turn_into_wide <- function(df){
#' turn_into_wide
#' Turns a long dataframe into wide dataframe
#'
#' @param df 
#'
#' @return df in wide format
#' @export
#'
#' @examples turn_into_wide(long_dataframe)
 df$value <- 1  
 df <- tidyr::pivot_wider(data = df, names_from = "combinations", values_from = "value")
 
 return(df)
}
 
tmp <- turn_into_wide(df = tmp)

total_unique_combinations <- length(unique(combinations$combinations))
combinations$combinations <- factor(combinations$combinations, levels = combinations$combinations)
 
ggplot2::ggplot(tail(combinations, 25), ggplot2::aes(x = n, y = combinations, label = n)) +
  ggplot2::geom_segment(ggplot2::aes(x = 0, y = combinations, xend = n, yend = combinations), color = "grey50") +
  ggplot2::geom_point(size=3, color = "lightblue") +
  ggplot2::geom_text(nudge_x = 25) +
  ggplot2::theme_bw() + 
  ggplot2::xlab("Counts") + 
  ggplot2::ylab("") +
  ggplot2::ggtitle(paste("Distribution of Genre Combinations (Total: ", total_unique_combinations, ")"))
 
 
 # Test
check_dims_genres <- test_that(
  "Check dims of genre matrices fit with new generated wide df", {
    expect_equal(total_unique_combinations, dim(tmp)[2]-1)
     }
)

```
**Beschreibung:**
Der Plot zeigt die Anzahl der Counts pro Genre. Der Plot zeigt, dass das Genre "Drama" und "Comedy" klar die meisten
Filme besitzen. Es hat sehr wenig Filme in den Bereichen "unkown", was gut ist. Gemäss dem vorherigen Plot wird die Grafik auch getrübt, dadurch, dass 
gewisse Filme über mehrere Genres verfügen. Es könnte sein, dass es viele Filme im Datensatz gibt, die nicht primär nur "Drama" Filme sind.



7.User-Genre-Profil Matrix mit Nutzerprofilen im Genre-Vektorraum erzeugen.
```{r}
########## Param ##########
NORMALIZED_BY_VIEWS <- TRUE

###########################
# Convert both into matrices
user_movie_mat <- as(MovieLense_binary, "matrix")


movie_genre_mat <- movie_genre %>%
  dplyr::select(-title) %>%
  as.matrix()

# Create user genre profile
if (NORMALIZED_BY_VIEWS){
  user_genre_mat <- ((user_movie_mat / as.vector(rowSums(user_movie_mat)))  %*% movie_genre_mat)
} else {
  user_genre_mat <- user_movie_mat %*% movie_genre_mat
}


# Test
check_both_matrices <- test_that(
  "Check matrices types", {
    expect_equal(class(user_movie_mat), class(movie_genre_mat))
  }
)

check_mat_dim <- test_that(
  "Check mat dims", {
    expect_equal(dim(user_movie_mat)[2], dim(movie_genre)[1])
  }
)

check_mat_dim_out <- test_that(
  "Check mat dims output", {
    expect_equal(dim(user_genre_mat), c(dim(user_movie_mat)[1], dim(movie_genre_mat)[2]))
  }
)
```
Achtung! Die Werte können grössere Werte als 1 pro User annehmen trotz Normalisierung der Gesamtviews per User, da gewisse Filme über mehrere
Genres verfügen.


8.Dimension der User-Genre-Profil Matrix prüfen und ausgeben.
```{r}
dim(user_genre_mat)
```
Die Matrix zeigt über die Reihen hinweg alle User und über die Spalten hinweg alle erzeugten Scores bezüglich ihrer Relation zu
einem bestimmten Genre.


9.Anzahl unterschiedlicher Nutzerprofile bestimmen, wenn Stärke der GenreKombination (a) vollständig bzw. (b) nur binär berücksichtigt wird.
```{r}
BINARY_THRESHOLD <- 0

# Create Binaray User-Genre Matrix
user_genre_mat_binary <- ifelse(user_genre_mat > BINARY_THRESHOLD, 1, 0)

plot_user_profiles <- function(M, user_idx = NULL, 
                              sample_size = 20, n_cols = 4){
  #' Plots all user profiles
  #'
  #' params:
  #'    user_genre_mat:   Matrix consisting of user genre ratings
  #'    sample_size:      Size of the sample to take
  #'    n_cols:           Ncols to plot.
  #' 
  #' in the Description section
  #'
  #' This part goes in the Details!
  if (user_idx){
    user_selection <- M[user_idx, ]
  } else {
    random_idx <- sample(seq(1, dim(M)[[1]]), 
                        size = sample_size)
    user_selection <- M[random_idx, ]
  }  
  user_selection <- as.data.frame(user_selection)
  user_selection <- rbind(rep(max(user_selection), 
                              nrow(user_selection)), 
                          rep(min(user_selection),
                             nrow(user_selection)), 
                                  user_selection)
  n_rows <- as.integer(sample_size / n_cols)
  par(mar = rep(1, 4))
  par(mfrow = c(n_rows, 4))

  for (i in 3:nrow(user_selection)){
    fmsb::radarchart(
      df  = user_selection[c(1:2, i), ],  
      pcol=rgb(0.2,0.5,0.5,0.9) , pfcol=rgb(0.2,0.5,0.5,0.5),
      plwd = 1, cglcol="grey", cglty=1, axislabcol="grey",
      caxislabels=seq(0,20,5), cglwd=0.8,
      vlcex=0.8, title = paste("User: ", row.names(user_selection)[i]))
    }
  }

random_idx <- sample(seq(1, dim(user_genre_mat_binary)[[1]]), 
                        size = 8)
plot_user_profiles(user_genre_mat_binary, user_idx = random_idx, 
                    sample_size = 8)
plot_user_profiles(user_genre_mat, user_idx = random_idx, 
                    sample_size = 8)
```
**Beschreibung:**

Die beiden Plots unterscheiden sich stark in ihren Wertebereichen. Der Wertebereich des binärisierten
Plots reicht bei jedem Nutzer von 0 bis nach 1. Die Grafik des binären Plots veränderts sich wenn der BINARY_THRESHOLD
verändert wird. Der Plot mit den normalen Ratings sieht wie erwartet aus. Die Spiderdiagramme zeigen die stärkste Ausprägung
meistens bei dem Genre Drama.


## Ähnlichkeit von Nutzern und Filmen
1.Cosinus-Ähnlichkeit zwischen User-Genre- und Movie-Genre-Matrix berechnen.

```{r}
calc_cosine_similarity <- function(UG, MG, make_sparse=FALSE){
  if (make_sparse){
    UG <- Matrix(UG, sparse = TRUE)
    MG <- Matrix(MG, sparse = TRUE) 
  }
  M <- UG %*% t(MG) / ( sqrt(rowSums(UG**2)) %*% t(sqrt(rowSums(MG**2))) )
  return(M)
}

similarity_matrix <- calc_cosine_similarity(user_genre_mat, movie_genre_mat)

# Check similarity results with package coop
check_similarity_results <- test_that(
  "Check mat dims with users", {
    expect_equal(similarity_matrix[1,1]  ,coop::cosine(user_genre_mat[1, ] ,movie_genre_mat[1, ]) )
  }
)
```

2.Dimension der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen prüfen uns ausgeben.
```{r}
dim(similarity_matrix)

# Run Tests on Dimensionality fo Similarity Matrix
check_mat_dim <- test_that(
  "Check mat dims with users", {
    expect_equal(dim(similarity_matrix)[1], dim(user_genre_mat)[1])
    expect_equal(dim(similarity_matrix)[2], dim(movie_genre_mat)[1])
  }
)
```
3.5-Zahlen Statistik für Matrix der Cosinus-Ähnlichkeiten prüfen uns ausgeben.
```{r}
fivenum(similarity_matrix)
```
4.Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot visualisieren.
```{r}
hist(similarity_matrix , breaks=40 , col = "lightblue" , 
     main="Distribution of Similarity Matrix" , xlab="Cosine Similarities", 
     xlim=c(0,1))

```
**Beschreibung:**
Der Plot zeigt die Verteilung der berechneten Ähnlichkeitsmasse pro User und Film innerhalb des Datensatzes.
Man erkennt eine starke Ausprägung der Nullwerte, respektive gar keine Similarity zwischen Nutzer und Filmen. Dies 
lässt sich mit der These vereinbaren, dass es Nutzer gibt, die fast keine Filme geschaut und vice-versa Filme, die fast nie geschaut
wurden. Ohne die starke Ausprägung wäre das Histogram praktisch normalverteilt.



5.Cosinus-Ähnlichkeiten von Nutzern und Filmen mit Dichteplot für Nutzer “241”, “414”, “477”, “526”, “640” und “710” visualisieren.
```{r}
user_selection <- similarity_matrix[c(241, 414, 477, 526, 640, 710), ]
row.names(user_selection)

user_selection <- as.data.frame(t(user_selection)) %>%
  reshape2::melt(value.name = "similarity")

colnames(user_selection) <- c("user", "similarity")

ggplot2::ggplot(data = user_selection, ggplot2::aes(x = similarity)) + 
  ggplot2::geom_boxplot(fill="grey", color = "black", notch = TRUE) + 
  facet_grid(rows = vars(user)) + 
  xlim(0, 1) + 
  labs(title = "Distribution of Similarities between User and Movies")
```
**Beschreibung:**

Der Plot zeigt die Verteilung der Similarites zwischen einem User und allen Filmen. Auf der rechten Seite ist die jeweilige 
ID des Users verzeichnet. Die Daten wurden anhand eines Boxplots visualisiert, um Unterschiede zwischen den Usern besser zu erkennen.
Man kann auf den ersten Blick anhand des Notches (95% Konfidenzintervall vom Mittelwert), dass sich die Nutzer statistisch signifikant voneinander
unterscheiden hinsichtlich ihrer Ähnlichkeit zwischen den Filmen. Eine weitere Auffälligkeit sind die einzelnen Ausreisser der Ähnlickeitsmasse von Nutzer 640, die aber auch auf die kleine Streuung der Similarities für diesen Nutzer zurückzuführen sind.


## Empfehlbare Filme

1.Bewertete Filme maskieren, d.h. “Negativabzug” der User-Items Matrix erzeugen, um anschliessend Empfehlungen herzuleiten.
```{r}
MovieLenseMat = as(MovieLense, "matrix")
MovieLenseMat_mask = ifelse(is.na(MovieLenseMat), 1, 0)
```
np.where(mat == 0, 1, 0)
2.Zeilensumme des “Negativabzuges” der User-Items Matrix für die User “5”, “25”, “50” und “150” ausgeben.
```{r}
SELECTED_USERS = c(5, 25, 50, 150)

###
Mask_sum = MovieLenseMat_mask
Mask_sum = data.frame(Sum = rowSums(Mask_sum))
Mask_sum$User <- factor(row.names(Mask_sum))

### Select users
sum_mask_users = Mask_sum[Mask_sum$User %in% SELECTED_USERS,]
sum_mask_users$User <- factor(sum_mask_users$User, levels = SELECTED_USERS)
  
```
```{r}
ggplot(data=sum_mask_users, aes(x=User, y=Sum)) +
  ggplot2::geom_bar(stat="identity") +   
  ggplot2::geom_text(aes(label=Sum), vjust=1.6, color="white", size=3.5) +
  ggplot2::ggtitle('Sum of unrated Movies of selected Users')
  ggplot2::theme_bw()
```

3.5-Zahlen Statistik der Zeilensumme des “Negativabzuges” der User-Items Matrix bestimmen.
```{r}
ggplot(Mask_sum, aes(y=Sum)) + 
  ggplot2::geom_boxplot(outlier.colour="red", outlier.shape=8,
                outlier.size=1) +
  ggplot2::ggtitle('Boxplot of Sum of unrated Movies per User') + 
  ggplot2::theme_bw()
fivenum(Mask_sum$Sum)
```




## Top-N Empfehlungen

1.Matrix für Bewertung aller Filme durch element-weise Multiplikation der Matrix der Cosinus-Ähnlichkeiten von Nutzern und Filmen und “Negativabzug” der User-Items Matrix erzeugen.
2.Dimension der Matrix für die Bewertung aller Filme prüfen.
3.Top-20 Listen pro Nutzer extrahieren.
4.Länge der Top-20 Listen pro Nutzer prüfen.
5.Verteilung der minimalen Ähnlichkeit für Top-N Listen für N = 10, 20, 50 und 100 für alle Nutzer visuell vergleichen.
6.Top-20 Empfehlungen für Nutzer “5”, “25”, “50” und “150” visuell evaluieren.
7.Für Nutzer “133” und “555” Profil mit Top-N Empfehlungen für N = 20, 30, 40, 50 analysieren, visualisieren und diskutieren.




